#include "PE_FILE.h"

PE_FILE::PE_FILE(PBYTE peBuffer, SIZE_T peSize) :
	DosHeader(NULL),
	NTHeader(NULL)
{
	_peBuffer = (PBYTE)VirtualAllocEx(GetCurrentProcess(), NULL, peSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 현재 프로세스에 악성코드 만큼 공간 할당

	if (_peBuffer != NULL)
	{
		ZeroMemory(_peBuffer, peSize);
		CopyMemory(_peBuffer, peBuffer, peSize);// 0으로 초기화 후 현재 프로세스 메모리 내 데이터 쓰기

		DosHeader = (PIMAGE_DOS_HEADER)_peBuffer;
		NTHeader = (PIMAGE_NT_HEADERS)&_peBuffer[DosHeader->e_lfanew]; // 헤더 정보 초기화
	}
}

PE_FILE::~PE_FILE()
{
	if (_peBuffer != NULL)
	{
		VirtualFreeEx(GetCurrentProcess(), (PVOID)_peBuffer, 0, MEM_RELEASE);
		_peBuffer = NULL;
	}
}


ULONG PE_FILE::imageSize()
{
	if (DosHeader == NULL &&
		NTHeader == NULL)
	{return 0;}
	return (ULONG)NTHeader->OptionalHeader.SizeOfImage;
}
USHORT PE_FILE::numberOfSection()
{
	return (USHORT)NTHeader->FileHeader.NumberOfSections;
}

ULONG PE_FILE::addressOfEntryPoint()
{
	return (ULONG)NTHeader->OptionalHeader.AddressOfEntryPoint;
}
LONG_PTR PE_FILE::Get_Relative_Offset(ULONG_PTR imagebase)
{
	return (LONG_PTR)imagebase - NTHeader->OptionalHeader.ImageBase;// 타겟 프로세스의 이미지 베이스에서 현재 프로세스의 이미지 베이스 차이 구함
}

ULONG_PTR PE_FILE::Get_FirstSection()
{
	return (ULONG_PTR)IMAGE_FIRST_SECTION(NTHeader);
}

ULONG_PTR PE_FILE::Get_NextSection(ULONG_PTR currentSection)
{
	return (ULONG_PTR)((PBYTE)currentSection + sizeof(IMAGE_SECTION_HEADER));
}

void PE_FILE::Set_Imagebase(LONG_PTR imagebase)
{
	NTHeader->OptionalHeader.ImageBase = (LONG_PTR)imagebase;// 현재프로세스  이미지베이스를 타겟 이미지 베이스로 초기화 
}

ULONG_PTR PE_FILE::memAlloc(SIZE_T size)
{
	ULONG_PTR retAddress = 0;
	retAddress = (ULONG_PTR)VirtualAllocEx(GetCurrentProcess(), NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (retAddress == NULL)
		return 0;

	ZeroMemory((PVOID)retAddress, size);

	return retAddress;// 현재메모리내 임시 할당
}

void PE_FILE::memFree(ULONG_PTR TempAddr)
{
	if (TempAddr != NULL)
	{
		VirtualFreeEx(GetCurrentProcess(), (PVOID)TempAddr, 0, MEM_RELEASE);
		TempAddr = NULL;
	}
}

PBYTE PE_FILE::peHeader()
{
	return (PBYTE)_peBuffer;
}

ULONG PE_FILE::peHeaderSize()
{
	return (ULONG)NTHeader->OptionalHeader.SizeOfHeaders;
}

PVOID PE_FILE::getAddress(HMODULE Module, char* FunctionName)
{
	PIMAGE_DATA_DIRECTORY DataDirectories = NULL;
	LPBYTE lpModule = (LPBYTE)Module; // dll 모듈 가져오기
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)lpModule;
	PIMAGE_NT_HEADERS NTHeaders = (PIMAGE_NT_HEADERS)(lpModule + DosHeader->e_lfanew);

	DataDirectories = &NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; // 디렉터리 엔트리 가져오기

	if (DataDirectories->VirtualAddress == 0 || DataDirectories->Size == 0)
	{
		return NULL;
	}

	PULONG ExportFunctionRVA = NULL;
	PULONG ExportFunctionNameRVA = NULL;
	PUSHORT ExportFunctionOridinal = NULL;

	PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(lpModule + DataDirectories->VirtualAddress); //DLL이므로 EXPORT 디렉터리내 해당함수를 찾음, 

	BOOLEAN Check_Name = (ULONG_PTR)FunctionName > USHRT_MAX;
	ULONG FunctionIndex = 0;
	ULONG FunctionRVA = 0;
	ULONG NameIndex;

	if (ExportDirectory->AddressOfFunctions == 0 || FunctionName[0] == '\0')
		return NULL;

	ExportFunctionRVA = (PULONG)(lpModule + ExportDirectory->AddressOfFunctions); //RVA 가져오기 Imagebase+RVA = VA
		
	if (ExportDirectory->AddressOfNames || ExportDirectory->AddressOfNameOrdinals)
	{
		ExportFunctionNameRVA = (PULONG)(lpModule + ExportDirectory->AddressOfNames); // 이름의 대한 RVA
		ExportFunctionOridinal = (PUSHORT)(lpModule + ExportDirectory->AddressOfNameOrdinals); //서수의 대한 RVA
	}
	else
	{
		return NULL;
	}

	for (NameIndex = 0; NameIndex < ExportDirectory->NumberOfNames; NameIndex++) 
	{
		PCSTR Find_NameValue = (PCSTR)(lpModule + ExportFunctionNameRVA[NameIndex]); //네임 테이블 내 함수 찾기
		if (Find_NameValue)
		{
			if (strncmp(Find_NameValue, FunctionName, 0x7fff) == 0) // 함수 이름 갖으면
			{
				FunctionIndex = ExportFunctionOridinal[NameIndex]; // 인덱스의 서수값(순서값)을 가져옴
				if (ExportDirectory->NumberOfFunctions <= FunctionIndex)
					return NULL;

				FunctionRVA = ExportFunctionRVA[FunctionIndex]; // 인덱스 서수값을 통해 RVA구함
				break;
			}
		}
	}
	if (FunctionRVA == 0)
		return NULL;

	return (FARPROC)(lpModule + FunctionRVA); // 실제 함수주소 VA
}

bool PE_FILE::resolveIAT(ULONG_PTR imageBase) //임시메모리 주소 
{
	PIMAGE_DATA_DIRECTORY DataDirectories = &NTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];// Import Directory 악성 dll 의  Import Directory 획득IMAGE_DIRECTORY_ENTRY_IMPORT가 가리키는 VA 주소에는 각 Import된 dll 파일의 구조체 정보를 갖고있다.

	if (DataDirectories->VirtualAddress == 0 || DataDirectories->Size == 0)
	{
		return false;
	}
	
	PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)imageBase + DataDirectories->VirtualAddress);//IID IMAGE_IMPORT_DESCRIPTOR 정의. 작성된 임시메모리의 IID 테이블 일거오기 

	while (ImportDescriptor->Name) // Name : DLL 이름 RVA 주소
	{
		char* ModuleName = ((char*)imageBase + ImportDescriptor->Name); // Name : DLL 이름 RVA 주소
		HMODULE hModule = LoadLibraryA(ModuleName);// dll 핸들 획득

		if (hModule == NULL)
		{
			return false;
		}

		PIMAGE_THUNK_DATA OriginalFirstThunk = (PIMAGE_THUNK_DATA)((PBYTE)imageBase + ImportDescriptor->OriginalFirstThunk); // OriginalFirstTHunk : INT(Import Name Table) RVA 주소
		PIMAGE_THUNK_DATA FirstThunk = (PIMAGE_THUNK_DATA)((PBYTE)imageBase + ImportDescriptor->FirstThunk); // FirstTHunk : IAT(Import Address Table) RVA 주소

		while (OriginalFirstThunk->u1.AddressOfData)
		{
			if (OriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)//서수로 확인
			{
				FirstThunk->u1.AddressOfData = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(OriginalFirstThunk->u1.Ordinal));  // 해당 DLL(hModule)의 INT 테이블을 확인하여 IAT 테이블 지정
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME ImportByName = (PIMAGE_IMPORT_BY_NAME)((char*)imageBase + OriginalFirstThunk->u1.AddressOfData); // 이름으로 
				FirstThunk->u1.AddressOfData = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)ImportByName->Name);// 임포트 함수 읽어와 IAT 테이블 리졸빙
			}

			OriginalFirstThunk++;
			FirstThunk++;
		}

		ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((char*)ImportDescriptor + sizeof(IMAGE_IMPORT_DESCRIPTOR));// 다음 DLL의 IID 획득
	}
	return true;
	
}

void PE_FILE::relocate(ULONG_PTR TempAddr, ULONG_PTR relativeOffset)
{
	if (TempAddr != 0 && relativeOffset != 0)
	{
		PIMAGE_DATA_DIRECTORY Reloacte_DataDirectory = (PIMAGE_DATA_DIRECTORY)(&NTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);

		if (Reloacte_DataDirectory->VirtualAddress != 0 && Reloacte_DataDirectory->Size != 0)// 재할당 디렉터리 주소 획득(프로세스내 할당된 악성코드 기준,
		{
			PIMAGE_BASE_RELOCATION pBaseRelocation = (PIMAGE_BASE_RELOCATION)(TempAddr + Reloacte_DataDirectory->VirtualAddress);// 임시 메모리주소에서 악성코드의 대할당 디렉터리 주소만큼 더하여 임시메모리 기준의 재할당 베이스 주소 획득)// RVA

			while (pBaseRelocation->SizeOfBlock)//각 블록의 크기
			{
				PBYTE VirtualAddress = (PBYTE)TempAddr + pBaseRelocation->VirtualAddress;//전체 기준 VA 획득
				DWORD dwEntryCount = (pBaseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)); // sizeof(WORD) 각 블로의 WORD 배열의 수, 블록의 사이즈에서 IMAGE_BASE_RELOCATION 구조체 크기 빼니 배열만 남음
				PWORD pRelocEntry = (PWORD)((PBYTE)pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION)); //시작주소 구조체 밑으로 WORD 타임의 배열 시작주소,     DWORD   VirtualAddress;DWORD   SizeOfBlock; 이후 주소

				while (dwEntryCount--)
				{
					WORD Type = (*pRelocEntry & 0xF000) >> 12;
					WORD Offset = *pRelocEntry & 0xFFF;

					switch (Type) // 베이스 재배치 형식
					{
					case IMAGE_REL_BASED_HIGH:
						*(ULONGLONG*)(VirtualAddress + Offset) += HIWORD(relativeOffset);//(VirtualAddress + Offset 이미 이거는 재배치 주소인데 추가로 타겟프로세스의 이미지베이스 차를 더한다.  
						break;
					case IMAGE_REL_BASED_LOW:
						*(ULONGLONG*)(VirtualAddress + Offset) += LOWORD(relativeOffset);
						break;
					case IMAGE_REL_BASED_HIGHLOW:
						*(DWORD*)(VirtualAddress + Offset) += (DWORD)relativeOffset;
						break;
					case IMAGE_REL_BASED_DIR64:
						*(ULONGLONG*)(VirtualAddress + Offset) += (ULONGLONG)relativeOffset;
						break;
					}

					pRelocEntry++;
				}

				pBaseRelocation = (PIMAGE_BASE_RELOCATION)((PBYTE)pBaseRelocation + pBaseRelocation->SizeOfBlock);// 다음 블록
			}
		}
	}
}

