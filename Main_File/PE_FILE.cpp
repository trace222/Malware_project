#include "PE_FILE.h"

PE_FILE::PE_FILE(PBYTE peBuffer, SIZE_T peSize) :
	DosHeader(NULL),
	NTHeader(NULL)
{
	_peBuffer = (PBYTE)VirtualAllocEx(GetCurrentProcess(), NULL, peSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (_peBuffer != NULL)
	{
		ZeroMemory(_peBuffer, peSize);
		CopyMemory(_peBuffer, peBuffer, peSize);

		DosHeader = (PIMAGE_DOS_HEADER)_peBuffer;
		NTHeader = (PIMAGE_NT_HEADERS)&_peBuffer[DosHeader->e_lfanew];
	}
}

PE_FILE::~PE_FILE()
{
	if (_peBuffer != NULL)
	{
		VirtualFreeEx(GetCurrentProcess(), (PVOID)_peBuffer, 0, MEM_RELEASE);
		_peBuffer = NULL;
	}
}


ULONG PE_FILE::imageSize()
{
	if (DosHeader == NULL &&
		NTHeader == NULL)
	{
		return 0;
	}

	return (ULONG)NTHeader->OptionalHeader.SizeOfImage;
}
USHORT PE_FILE::numberOfSection()
{
	return (USHORT)NTHeader->FileHeader.NumberOfSections;
}

ULONG PE_FILE::addressOfEntryPoint()
{
	return (ULONG)NTHeader->OptionalHeader.AddressOfEntryPoint;
}
LONG_PTR PE_FILE::Get_Relative_Offset(ULONG_PTR imagebase)
{
	return (LONG_PTR)imagebase - NTHeader->OptionalHeader.ImageBase;
}

ULONG_PTR PE_FILE::Get_FirstSection()
{
	return (ULONG_PTR)IMAGE_FIRST_SECTION(NTHeader);
}

ULONG_PTR PE_FILE::Get_NextSection(ULONG_PTR currentSection)
{
	return (ULONG_PTR)((PBYTE)currentSection + sizeof(IMAGE_SECTION_HEADER));// 현재 섹션에서 구조체 크기만큼 더하기 (IMAGE_FILE_HEADER의 NumberOfSections 필드에 있는 섹션의 개수만큼 IMAGE_SECTION_HEADER 가 존재)
}

void PE_FILE::Set_Imagebase(LONG_PTR imagebase)
{
	NTHeader->OptionalHeader.ImageBase = (LONG_PTR)imagebase;
}

ULONG_PTR PE_FILE::memAlloc(SIZE_T size)
{
	ULONG_PTR retAddress = 0;
	retAddress = (ULONG_PTR)VirtualAllocEx(GetCurrentProcess(), NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (retAddress == NULL)
		return 0;

	ZeroMemory((PVOID)retAddress, size);

	return retAddress;
}

void PE_FILE::memFree(ULONG_PTR TempAddr)
{
	if (TempAddr != NULL)
	{
		VirtualFreeEx(GetCurrentProcess(), (PVOID)TempAddr, 0, MEM_RELEASE);
		TempAddr = NULL;
	}
}

PBYTE PE_FILE::peHeader()
{
	return (PBYTE)_peBuffer;
}

ULONG PE_FILE::peHeaderSize()
{
	return (ULONG)NTHeader->OptionalHeader.SizeOfHeaders;
}

PVOID PE_FILE::getAddress(HMODULE Module, char* FunctionName)
{
	PIMAGE_DATA_DIRECTORY DataDirectories = NULL;
	LPBYTE lpModule = (LPBYTE)Module; // dll 모듈 가져오기
	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)lpModule;
	PIMAGE_NT_HEADERS NTHeaders = (PIMAGE_NT_HEADERS)(lpModule + DosHeader->e_lfanew);

	DataDirectories = &NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; // 디렉터리 엔트리 가져오기

	if (DataDirectories->VirtualAddress == 0 || DataDirectories->Size == 0)
	{
		return NULL;
	}

	PULONG ExportFunctionVA = NULL;
	PULONG ExportFunctionNameVA = NULL;
	PUSHORT ExportFunctionOridinal = NULL;

	PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(lpModule + DataDirectories->VirtualAddress);

	BOOLEAN Check_Name = (ULONG_PTR)FunctionName > USHRT_MAX;
	ULONG FunctionIndex = 0;
	ULONG FunctionRVA = 0;
	ULONG NameIndex;

	if (ExportDirectory->AddressOfFunctions == 0 || FunctionName[0] == '\0')
		return NULL;

	ExportFunctionVA = (PULONG)(lpModule + ExportDirectory->AddressOfFunctions); //RVA 가져오기 Imagebase+RVA = VA
		
	if (ExportDirectory->AddressOfNames || ExportDirectory->AddressOfNameOrdinals)
	{
		ExportFunctionNameVA = (PULONG)(lpModule + ExportDirectory->AddressOfNames); // 이름의 대한 RVA
		ExportFunctionOridinal = (PUSHORT)(lpModule + ExportDirectory->AddressOfNameOrdinals); //서수의 대한 RVA
	}
	else
	{
		return NULL;
	}

	for (NameIndex = 0; NameIndex < ExportDirectory->NumberOfNames; NameIndex++) 
	{
		PCSTR Find_NameValue = (PCSTR)(lpModule + ExportFunctionNameVA[NameIndex]); //네임 테이블 내 함수 찾기
		if (Find_NameValue)
		{
			if (strncmp(Find_NameValue, FunctionName, 0x7fff) == 0) // 함수 이름 갖으면
			{
				FunctionIndex = ExportFunctionOridinal[NameIndex]; // 인덱스의 서수값(순서값)을 가져옴
				if (ExportDirectory->NumberOfFunctions <= FunctionIndex)
					return NULL;

				FunctionRVA = ExportFunctionVA[FunctionIndex]; // 인덱스 서수값을 통해 RVA구함
				break;
			}
		}
	}
	
	/* 서수값으로 확인
	{
		ULONG Ordinal = (USHORT)(ULONG_PTR)FunctionName; 
		if (Ordinal < ExportDirectory->Base)
			return NULL;
		FunctionIndex = Ordinal - ExportDirectory->Base;
		if (ExportDirectory->NumberOfFunctions <= FunctionIndex)
			return NULL;
		FunctionRVA = ExportFunctionVA[FunctionIndex];
	}*/

	if (FunctionRVA == 0)
		return NULL;

	return (FARPROC)(lpModule + FunctionRVA); // 실제 함수주소 VA
}

bool PE_FILE::resolveIAT(ULONG_PTR imageBase) 
{
	PIMAGE_DATA_DIRECTORY DataDirectories = &NTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];// Import Directory

	if (DataDirectories->VirtualAddress == 0 || DataDirectories->Size == 0)
	{
		return false;
	}
	
	PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)imageBase + DataDirectories->VirtualAddress);//IID

	while (ImportDescriptor->Name)
	{
		char* ModuleName = ((char*)imageBase + ImportDescriptor->Name);
		HMODULE hModule = LoadLibraryA(ModuleName);

		if (hModule == NULL)
		{
			return false;
		}

		PIMAGE_THUNK_DATA OriginalFirstThunk = (PIMAGE_THUNK_DATA)((PBYTE)imageBase + ImportDescriptor->OriginalFirstThunk);
		PIMAGE_THUNK_DATA FirstThunk = (PIMAGE_THUNK_DATA)((PBYTE)imageBase + ImportDescriptor->FirstThunk);

		while (OriginalFirstThunk->u1.AddressOfData)
		{
			if (OriginalFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				FirstThunk->u1.AddressOfData = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(OriginalFirstThunk->u1.Ordinal));  //DLL 모듈의 베이스어드레스를 나의 IAT테이블에 기록
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME ImportByName = (PIMAGE_IMPORT_BY_NAME)((char*)imageBase + OriginalFirstThunk->u1.AddressOfData);
				FirstThunk->u1.AddressOfData = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)ImportByName->Name);
			}

			OriginalFirstThunk++;
			FirstThunk++;
		}

		ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((char*)ImportDescriptor + sizeof(IMAGE_IMPORT_DESCRIPTOR));
	}
	return true;
	
}

void PE_FILE::relocate(ULONG_PTR TempAddr, ULONG_PTR relativeOffset)
{
	if (TempAddr != 0 && relativeOffset != 0)
	{
		PIMAGE_DATA_DIRECTORY Reloacte_DataDirectory = (PIMAGE_DATA_DIRECTORY)(&NTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);// 재배치 테이블(base relocation table)

		if (Reloacte_DataDirectory->VirtualAddress != 0 && Reloacte_DataDirectory->Size != 0)
		{
			PIMAGE_BASE_RELOCATION pBaseRelocation = (PIMAGE_BASE_RELOCATION)(TempAddr + Reloacte_DataDirectory->VirtualAddress);

			while (pBaseRelocation->SizeOfBlock) // SizeOfBlock - IMAGE_BASE_RELOCATION 구조체를 포함한 재배치 항목 데이터들의 전체 크기
			{
				PBYTE VirtualAddress = (PBYTE)TempAddr + pBaseRelocation->VirtualAddress;
				DWORD dwEntryCount = (pBaseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				PWORD pRelocEntry = (PWORD)((PBYTE)pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));

				while (dwEntryCount--)
				{
					WORD Type = (*pRelocEntry & 0xF000) >> 12;
					WORD Offset = *pRelocEntry & 0xFFF;

					switch (Type) // 베이스 재배치 형식
					{
					case IMAGE_REL_BASED_HIGH:
						*(ULONGLONG*)(VirtualAddress + Offset) += HIWORD(relativeOffset);
						break;
					case IMAGE_REL_BASED_LOW:
						*(ULONGLONG*)(VirtualAddress + Offset) += LOWORD(relativeOffset);
						break;
					case IMAGE_REL_BASED_HIGHLOW:
						*(DWORD*)(VirtualAddress + Offset) += (DWORD)relativeOffset;
						break;
					case IMAGE_REL_BASED_DIR64:
						*(ULONGLONG*)(VirtualAddress + Offset) += (ULONGLONG)relativeOffset;
						break;
					}

					pRelocEntry++;
				}

				pBaseRelocation = (PIMAGE_BASE_RELOCATION)((PBYTE)pBaseRelocation + pBaseRelocation->SizeOfBlock);
			}
		}
	}
}

