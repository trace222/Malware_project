#include "File_Injector.h"
#include "PE_FILE.h"
#include "directsyscall.h"

File_Injector::File_Injector(HANDLE processHandle)
{
	_allocAddress = 0;
	_entrypointOffset = 0;
	process_handle = NULL;
	if (processHandle)
	{
		process_handle = processHandle;
		remote_check = true;
	}
	else
	{
		remote_check = false;
		process_handle = GetCurrentProcess();
	}
}

File_Injector::~File_Injector()
{
	if (_allocAddress)
	{
		//callEntryPoint_(_allocAddress, _entrypointOffset, DLL_PROCESS_DETACH);

		if (VirtualFreeEx(process_handle, (PVOID)_allocAddress, 0, MEM_RELEASE))
		{
			if (remote_check)
			{
				CloseHandle(process_handle);
				process_handle = NULL;
				remote_check = false;
			}
			_allocAddress = 0;
			_entrypointOffset = 0;
		}
	}
}

ULONG_PTR File_Injector::alloc(SIZE_T size, ULONG_PTR baseAddress, bool Syscalltype)
{
	ULONG_PTR retAddress = 0;
	NTSTATUS status = 0;
	PVOID BaseAddress_ds = (PVOID)baseAddress;
	SIZE_T dsSize = size;


	if (Syscalltype)
	{
		status = (ULONG_PTR)DirectNtAllocateVirtualMemory(process_handle, &BaseAddress_ds, 0, &dsSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (status == 0)
			retAddress = (ULONG_PTR)BaseAddress_ds;
	}
	else
	{
		retAddress = (ULONG_PTR)VirtualAllocEx(process_handle, (LPVOID)baseAddress, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	}

	if (!remote_check)
	{
		if (retAddress != NULL)
			ZeroMemory((PVOID)retAddress, size);
	}

	_allocAddress = retAddress;

	return retAddress;
}
void File_Injector::writeHeader(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, ULONG srcSize)
{
	RtlCopyMemory((PVOID)destination_Addr, (PVOID)source_Addr, srcSize);
}

void File_Injector::writeSection(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, ULONG_PTR sectionAddress)
{
	PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)sectionAddress;

	RtlCopyMemory(((PBYTE)destination_Addr + pSection->VirtualAddress), ((PBYTE)source_Addr + pSection->PointerToRawData), pSection->SizeOfRawData);
}
bool File_Injector::WriteVirtualMemory(ULONG_PTR destination_Addr, ULONG_PTR source_Addr, SIZE_T size, bool Syscalltype)
{
	SIZE_T writtenSize = 0;

	if (Syscalltype)
	{
		if (!DirectNtWriteVirtualMemory(process_handle, (PVOID)destination_Addr, (PBYTE)source_Addr, (ULONG)size, (PULONG)&writtenSize))
			return false;
	}
	else
	{
		if (!WriteProcessMemory(process_handle, (PVOID)destination_Addr, (PBYTE)source_Addr, size, &writtenSize))
			return false;
	}

	return true;
}


ULONG File_Injector::callEntryPoint(ULONG_PTR baseAddress, ULONG addressOfEntryPoint)
{
	typedef ULONG(APIENTRY* PFN_DLL_MAIN)(HMODULE DllHandle, ULONG Reason, LPVOID Reserved);

	ULONG Result = ((PFN_DLL_MAIN)((char*)baseAddress + addressOfEntryPoint)) (
		(HMODULE)baseAddress,
		DLL_PROCESS_ATTACH,
		NULL
		);
	return 0;
}

bool File_Injector::Inject_Execute(ULONG_PTR destination_Addr, bool Syscalltype)
{
	HANDLE hThread = NULL;

	if (!remote_check)
	{
		hThread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)destination_Addr, NULL, 0, NULL);
	}
	else
	{
		hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)destination_Addr, NULL, 0, NULL);
	}
	if (hThread != NULL)
	{
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		return true;
	}

	return false;
}

