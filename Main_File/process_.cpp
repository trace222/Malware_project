#include "process_.h"
#include "phnt.h"
#include "directsyscall.h"

process::process() : 
	check_Run(false),
	_thread(NULL),
	process_handle(NULL),
	_pthreadContext(NULL),
	process_handleImageBase(0)
{}

process::~process()
{
	if (!check_Run)
	{
		if (_thread != NULL)
		{
			CloseHandle(_thread);
			_thread = NULL;
		}

		if (process_handle != NULL)
		{
			CloseHandle(process_handle);
			process_handle = NULL;
		}

		if (_pthreadContext != NULL)
		{
			HeapFree(GetProcessHeap(), 0, _pthreadContext);
			_pthreadContext = NULL;
		}
	}
}

HANDLE process::handle()
{
	if (!check_Run)
		return NULL;

	return process_handle;
}

bool process::create(PWCHAR pwszProcessPath, bool bSuspended, bool Syscalltype)
{
	STARTUPINFO start_info = { 0, };
	PROCESS_INFORMATION process_info = { 0, };
	ULONG CreateFlag = bSuspended == true ? CREATE_SUSPENDED : 0;
	NTSTATUS status = STATUS_SUCCESS;
	PROCESS_BASIC_INFORMATION ProcessBasicInfo = { 0, };
	PEB ProcessPeb = { 0, };
	ULONG ulProcessInfoLength = 0;
	SIZE_T ulPebLength = 0;

	start_info.cb = sizeof(STARTUPINFO);

	if (!CreateProcess(NULL, pwszProcessPath, NULL, NULL, FALSE, CreateFlag, NULL, NULL, &start_info, &process_info))
	{
		return false;
	}

	_thread = process_info.hThread;
	process_handle = process_info.hProcess;

	if (bSuspended)
		getThreadContext();

	if (Syscalltype)
	{
		status = DirectNtQueryInformationProcess(
			process_handle,
			ProcessBasicInformation,
			&ProcessBasicInfo,
			sizeof(PROCESS_BASIC_INFORMATION),
			&ulProcessInfoLength
		);
	}
	else
	{
		status = NtQueryInformationProcess(
			process_handle,
			ProcessBasicInformation,
			&ProcessBasicInfo,
			sizeof(PROCESS_BASIC_INFORMATION),
			&ulProcessInfoLength
		);
	}


	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	if (Syscalltype)
	{
		status = DirectNtReadVirtualMemory(
			process_handle,
			(PVOID)ProcessBasicInfo.PebBaseAddress,
			&ProcessPeb,
			sizeof(ProcessPeb),
			(PULONG)&ulPebLength
		);
	}
	else
	{
		status = NtReadVirtualMemory(
			process_handle,
			(PVOID)ProcessBasicInfo.PebBaseAddress,
			&ProcessPeb,
			sizeof(ProcessPeb),
			(PULONG)&ulPebLength
		);
	}

	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	process_handleImageBase = (ULONG_PTR)ProcessPeb.ImageBaseAddress;

	check_Run = true;

    return true;
}

ULONG_PTR process::imagebase()
{
	return process_handleImageBase;
}

bool process::unmap(ULONG_PTR imagebase, bool Syscalltype)
{
	NTSTATUS status = STATUS_SUCCESS;

	if (Syscalltype)
	{
		status = DirectNtUnmapViewOfSection(process_handle, (PVOID)imagebase);
	}
	else
	{
		status = NtUnmapViewOfSection(process_handle, (PVOID)imagebase);
	}

	if (status != STATUS_SUCCESS)
	{
		return false;
	}

	return true;
}

bool process::patchEntryPoint(ULONG_PTR baseAddress, ULONG_PTR addressOfEntryPoint)
{
	/*#ifdef _M_IX86
		_pthreadContext->Eax = baseAddress + addressOfEntryPoint;
	#else
		_pthreadContext->Rcx = baseAddress + addressOfEntryPoint;
	#endif
	*/
	_pthreadContext->Rcx = baseAddress + addressOfEntryPoint;

	if (SetThreadContext(_thread, _pthreadContext))
		return true;

	return false;
}

void process::resume()
{
	ResumeThread(_thread);
	WaitForSingleObject(_thread, INFINITE);
}


bool process::getThreadContext()
{
	_pthreadContext = (LPCONTEXT)HeapAlloc(GetProcessHeap(), 0, sizeof(CONTEXT));

	if (_pthreadContext == NULL)
		return false;

	memset(_pthreadContext, 0, sizeof(CONTEXT));

	_pthreadContext->ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext(_thread, _pthreadContext))
	{
		return false;
	}	

	return true;
}

